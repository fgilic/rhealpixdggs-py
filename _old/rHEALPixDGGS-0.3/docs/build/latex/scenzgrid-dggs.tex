% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12ptopenany,oneside]{sphinxmanual}
\usepackage[utf8x]{inputenc}

\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{xifthen}    % provides \isempty test
\newcommand{\del}{\partial}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\reals}{\mathbb{R}}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\cat}{\,\,\widehat{}\,\,}
\newcommand{\phat}{\hat{p}}
\newcommand{\hhat}{\hat{h}}
\newcommand{\Hhat}{\hat{H}}
\newcommand{\rh}{\underline{h}}
\newcommand{\rhhat}{\hat{\rh}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\maxlevel}{L}
\newcommand{\llt}{<_\text{lex}}
\newcommand{\tge}{\trianglerighteq}
\newcommand{\tle}{\trianglelefteq}
\newcommand{\tlt}{\triangleleft}
\newcommand{\nam}{\mathop{\mathrm{name}}}
\newcommand{\cell}[1][]{
  \ifthenelse{\isempty{#1}}
    {\square}   % if #1 is empty
    {\boxed{#1}}  % if #1 is not empty
}
%\newcommand{\cell}[1]{\boxed{#1}}
\newcommand{\ind}{\mathop{\mathrm{index}}}
\newcommand{\bind}{\mathop{\mathrm{Index}}}
\newcommand{\val}{\mathop{\mathrm{value_9}}}
\newcommand{\loc}{\mathop{\mathrm{location}}}

\title{scenzgrid-dggs Documentation}
\date{January 29, 2013}
\release{0.3}
\author{Alexander Raichev}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{introduction:introduction}\label{introduction:welcome-to-scenzgrid-dggs-s-documentation}\label{introduction::doc}
SCENZ-Grid is a geographic analysis system currently under development by Landcare Research, New Zealand.
scenzgrid-dggs is a collection of Python modules that implements SCENZ-Grid's discrete global grid system (DGGS), which is an instance of the rHEALPix DGGS.

This documentation assumes you are familiar with the rHEALPix DGGS as described in {\hyperref[introduction:grs2013]{{[}GRS2013{]}}} and familiar with basic Python 2.7.x usage as described in, say, \href{http://docs.python.org/2/tutorial/}{The Python Tutorial}.


\section{Dependencies}
\label{introduction:dependencies}\begin{itemize}
\item {} 
\href{http://python.org/}{Python 2.7}

\item {} 
\href{http://www.scipy.org/}{numpy and scipy}
Third-party Python modules for scientific computation.

\item {} 
\href{http://www.sagemath.org}{Sage}
(Optional) Third-party Python package for symbolic mathematics.
Needed only for a few optional graphics methods.

\end{itemize}


\section{Installation}
\label{introduction:installation}
The modules of scenzgrid-dggs are open source and available for download at Landcare's git repository \href{http://code.scenzgrid.org/index.php/p/scenzgrid-py/}{http://code.scenzgrid.org/index.php/p/scenzgrid-py/} and can be cloned via the command \code{git clone git@code.scenzgrid.org:scenzgrid-py.git}.


\section{Usage}
\label{introduction:usage}
To use the scenzgrid-dggs modules, start a Python session in the directory where you downloaded the modules and import the modules.
Here are some examples.
For a list of all methods available, see the application programming interface (API) in the following chapters.


\subsection{Using \texttt{projections.py}}
\label{introduction:using-projections-py}
The \code{projections} module implements the HEALPix and rHEALPix map projections on oblate ellipsoids of revolution whose authalic sphere is the unit sphere.
Because of this restriction, it is not so useful by itself.
Still, here are a few examples.

Import all the classes, methods, and constants from the module

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{projections} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

Project some points of an oblate ellipsoid of revolution using the HEALPix and (1, 2)-rHEALPix projections.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.2}  \PYG{c}{\PYGZsh{} Eccentricity of ellipsoid}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{n}{e}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{k}{print} \PYG{n}{q}
\PYG{g+go}{(0.27646508139326409, 1.0618632447907124)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{n}{e}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}
\PYG{g+go}{(6.3611093629270335e-15, 59.999997971669899) (0, 60)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{n}{rhealpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{n}{e}\PYG{p}{,} \PYG{n}{north}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{south}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{k}{print} \PYG{n}{q}
\PYG{g+go}{(-0.27646508139326409, 1.0618632447907124)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{rhealpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{n}{e}\PYG{p}{,} \PYG{n}{north}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{south}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{,} \PYG{n}{p}
\PYG{g+go}{(6.3611093629270335e-15, 59.999997971669899) (0, 60)}
\end{Verbatim}


\subsection{Using \texttt{grids.py}}
\label{introduction:using-grids-py}
The \code{grids} module implements the rHEALPix DGGS and various operations thereupon.
It depends upon the \code{projections} module.

Import all the classes, methods, and constants from the module

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{grids} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

Create the (0, 0)-rHEALPix DGGS based upon the WGS84 ellipsoid.
Use degrees for angular measurements

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{n}{ellps}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{WGS84}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{south}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{north}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}
\PYG{g+go}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}Earth model\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}}
\PYG{g+go}{lengths measured in meters and angles measured in degrees}
\PYG{g+go}{ellipsoid: WGS84}
\PYG{g+go}{    major radius: 6378137}
\PYG{g+go}{    flattening factor: 0.00335281066475}
\PYG{g+go}{    minor radius: 6356752.31425}
\PYG{g+go}{    eccentricity: 0.0818191908426}
\PYG{g+go}{    authalic sphere radius: 6371007.18092}
\PYG{g+go}{central meridian: 0}
\PYG{g+go}{north pole square position: 0}
\PYG{g+go}{south pole square position: 0}
\PYG{g+go}{max resolution: 1.0}
\PYG{g+go}{max cell level: 15}
\end{Verbatim}

Pick a (longitude-latitude) point on the ellipsoid and find the level 1 cell that contains it

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{surface}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ellipsoid}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{;} \PYG{k}{print} \PYG{n}{c}
\PYG{g+go}{Q0}
\end{Verbatim}

Find the planar (edge) neighbors of this cell

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{p}{(}\PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{plane}\PYG{l+s}{'}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print} \PYG{n}{direction}\PYG{p}{,} \PYG{n}{cell}
\PYG{g+go}{down Q3}
\PYG{g+go}{right Q1}
\PYG{g+go}{up N2}
\PYG{g+go}{left P2}
\end{Verbatim}

Compute the ellipsoidal shape and ellipsoidal nuclei of these cells

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cells} \PYG{o}{=} \PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{cell} \PYG{o+ow}{in} \PYG{n}{cells}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print} \PYG{n}{cell}\PYG{p}{,} \PYG{n}{cell}\PYG{o}{.}\PYG{n}{ellipsoidal\PYGZus{}shape}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cell}\PYG{o}{.}\PYG{n}{nucleus\PYGZus{}and\PYGZus{}vertices}\PYG{p}{(}\PYG{n}{surface}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{ellipsoid}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{Q3 rectangle (14.999999999999998, 0.0)}
\PYG{g+go}{Q1 rectangle (45.0, 26.490118738229611)}
\PYG{g+go}{N2 dart (0.0, 58.528017480415983)}
\PYG{g+go}{P2 rectangle (-14.999999999999998, 26.490118738229611)}
\end{Verbatim}


\chapter{The projections Module}
\label{projections:module-projections}\label{projections::doc}\label{projections:the-projections-module}\index{projections (module)}
The Python 2.7 module implements the cartographic projections used in SCENZ-Grid.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2011-09-27: Split projection functions and pixelation 
functions into separate files.

\item {} 
AR, 2011-10-04: Tidied a little. Improved variable names.

\item {} 
AR, 2011-10-06: Added more examples and more default arguments.

\item {} 
AR, 2011-10-23: Added more error-checking, such as the function in\_image().

\item {} 
AR, 2012-03-07: Changed `rot' to `rotate'.

\item {} 
AR, 2012-03-23: Fixed a conceptual bug in combine\_caps() and get\_cap(). Now polar caps actually assemble on top of the caps numbered north and south.

\item {} 
AR, 2012-03-26: Changed in\_image() to accept a radius argument.

\item {} 
AR, 2012-04-16: Imported NumPy instead of SciPy.

\item {} 
AR, 2012-06-13: Simplified get\_cap() to cap() and simplified combine\_caps().

\item {} 
AR, 2012-07-10: Corrected a subtle longitude rounding error in healpix\_sphere(inverse=True).

\item {} 
AR, 2012-08-31: Redefined the projections for only the unit sphere and 
the ellipsoid with eccentricity e and authalic sphere equal to the unit
sphere. Will handle scaling of spheres/ellipsoids in grids.py  
instead. This simplifies the code and puts it more in line with proj4
design, which also deals with scaling as a pre-/post-processing step outside
of the projection definitions.

\item {} 
AR, 2012-09-03: Corrected WGS84\_f, the WGS84 ellipsoid flattening factor.

\end{itemize}

NOTE:

All lengths are measured in meters and all angles are measured in radians 
unless indicated otherwise.

These projections work only for ellipsoids and not for general (triaxial) ellipsoids.

Except when manipulating positive integers, I avoid the modulo function `\%' 
and insted write everything in terms of `floor()'.
This is because Python interprets the sign of `\%' differently than
Java or C, and I don't want to confuse people who are translating this code
to those languages.
\index{auth\_lat() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.auth_lat}\pysiglinewithargsret{\code{projections.}\bfcode{auth\_lat}}{\emph{phi}, \emph{e}, \emph{inverse=False}}{}
Given a point of geographic latitude \emph{phi} on an ellipse of 
eccentricity \emph{e}, return the authalic latitude of the point.
If \emph{inverse=True}, then compute its inverse approximately.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{beta} \PYG{o}{=} \PYG{n}{auth\PYGZus{}lat}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{WGS84\PYGZus{}E}\PYG{p}{)}\PYG{p}{;} \PYG{n}{beta}
\PYG{g+go}{0.78315895611802222}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{auth\PYGZus{}lat}\PYG{p}{(}\PYG{n}{beta}\PYG{p}{,} \PYG{n}{WGS84\PYGZus{}E}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}
\PYG{g+go}{0.78539816331575041}
\PYG{g+go}{0.7853981633974483}
\end{Verbatim}

\end{fulllineitems}

\index{cap() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.cap}\pysiglinewithargsret{\code{projections.}\bfcode{cap}}{\emph{x}, \emph{y}, \emph{north=0}, \emph{south=0}, \emph{inverse=False}}{}
Return the number of the polar cap and region that \emph{(x, y)} lies in.
If \emph{inverse=False}, then assume \emph{(x,y)} lies in the image of the HEALPix 
projection of the unit sphere.
If \emph{inverse=True}, then assume \emph{(x,y)} lies in the image of the 
\emph{(north, south)}-rHEALPix projection of the unit sphere.

INPUT:
\begin{itemize}
\item {} 
\emph{x, y} - Coordinates in the HEALPix or rHEALPix (if \emph{inverse=True}) 
projection of the unit sphere.

\item {} 
\emph{north, south} - Integers between 0 and 3 indicating the positions
of the north pole square and south pole square respectively.
See rhealpix\_sphere() docstring for a diagram.

\item {} 
\emph{inverse} - (Optional; default = False) Boolean. If False, then compute
forward function. If True, then compute inverse function.

\end{itemize}

OUTPUT:

The pair (cap\_number, region).
Here region equals `north' (polar), `south' (polar), or `equatorial', 
indicating where \emph{(x, y)} lies.
If region = `equatorial', then cap\_number = None.
Suppose now that region != `equatorial'.
If \emph{inverse=False}, then cap\_number is the number (= 0, 1, 2, or 3) of 
the HEALPix polar cap Z that \emph{(x, y)} lies in.
If \emph{inverse=True}, then cap\_number is the number (= 0, 1, 2, or 3) of 
the HEALPix polar cap that \emph{(x, y)} will get moved into.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cap}\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{g+go}{(1, 'north')}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cap}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{(1, 'north')}
\end{Verbatim}

NOTE:

In the HEALPix projection, the polar caps are labeled 0--3 from 
east to west like this:

\begin{Verbatim}[commandchars=\\\{\}]
    *       *       *       *       
  * 0 *   * 1 *   * 2 *   * 3 *        
*-------*-------*-------*-------*
\textbar{}       \textbar{}       \textbar{}       \textbar{}       \textbar{}
\textbar{}       \textbar{}       \textbar{}       \textbar{}       \textbar{}
\textbar{}       \textbar{}       \textbar{}       \textbar{}       \textbar{}
*-------*-------*-------*-------*
  * 0 *   * 1 *   * 2 *   * 3 *
    *       *       *       *
\end{Verbatim}

In the rHEALPix projection these polar caps get rearranged
into a square with the caps numbered \emph{north} and \emph{south} remaining fixed.
For example, if \emph{north} = 1 and \emph{south} = 3, then the caps get
rearranged this way:

\begin{Verbatim}[commandchars=\\\{\}]
North polar square:     *-------*       
                        \textbar{} * 3 * \textbar{}    
                        \textbar{} 0 * 2 \textbar{}    
                        \textbar{} * 1 * \textbar{}    
                    ----*-------*----
                    
South polar square: ----*-------*----
                        \textbar{} * 3 * \textbar{}
                        \textbar{} 2 * 0 \textbar{}
                        \textbar{} * 1 * \textbar{}
                        *-------*
\end{Verbatim}

\end{fulllineitems}

\index{combine\_caps() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.combine_caps}\pysiglinewithargsret{\code{projections.}\bfcode{combine\_caps}}{\emph{x}, \emph{y}, \emph{north=0}, \emph{south=0}, \emph{inverse=False}}{}
Rearrange point \emph{(x, y)} in the HEALPix projection by 
combining the polar caps into two polar squares.
Put the north polar square in position \emph{north} and 
the south polar square in position \emph{south}.
If \emph{inverse=True}, uncombine the polar caps.

INPUT:
\begin{itemize}
\item {} 
\emph{x, y} - Coordinates in the HEALPix projection of the unit sphere.

\item {} 
\emph{north, south} - Integers between 0 and 3 indicating the positions
of the north polar square and south polar square respectively.
See rhealpix\_sphere() docstring for a diagram.

\item {} 
\emph{inverse} - (Optional; default = False) Boolean. If False, then compute
forward function. If True, then compute inverse function.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{u}\PYG{p}{,} \PYG{n}{v} \PYG{o}{=} \PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{combine\PYGZus{}caps}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}
\PYG{g+go}{(-1.8325957145940459, 1.5707963267948966)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{combine\PYGZus{}caps}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}
\PYG{g+go}{(-0.78539816339744828, 1.0471975511965976)}
\PYG{g+go}{(-0.7853981633974483, 1.0471975511965976)}
\end{Verbatim}

\end{fulllineitems}

\index{ellipsoid\_parameters() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.ellipsoid_parameters}\pysiglinewithargsret{\code{projections.}\bfcode{ellipsoid\_parameters}}{\emph{a}, \emph{f}}{}
Given the major radius \emph{a} and flattening factor \emph{f} of a
ellipsoid, return its minor radius, eccentricity, and authalic 
sphere radius.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{ellipsoid\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{WGS84\PYGZus{}A}\PYG{p}{,} \PYG{n}{WGS84\PYGZus{}F}\PYG{p}{)}
\PYG{g+go}{(6356752.314245179, 0.081819190842621486, 6371007.1809184756)}
\end{Verbatim}

\end{fulllineitems}

\index{healpix\_ellipsoid() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.healpix_ellipsoid}\pysiglinewithargsret{\code{projections.}\bfcode{healpix\_ellipsoid}}{\emph{u}, \emph{v}, \emph{e}, \emph{lon0=0}, \emph{degrees=False}, \emph{inverse=False}}{}
Compute the forward and inverse signature functions of the HEALPix 
projection of an oblate ellipsoid with eccentricity \emph{e} whose authalic
sphere is the unit sphere with central meridian \emph{lon0}.

INPUT:
\begin{itemize}
\item {} 
\emph{u, v} - If \emph{inverse=False}, then these are geographic coordinates.
Any input angles are accepted and get standardized to lie in the intervals 
-pi \textless{}= \emph{u} \textless{} pi and -pi/2 \textless{}= \emph{v} \textless{}= pi/2 via wrap\_longitude() and 
wrap\_latitude().
If \emph{inverse=True}, then these are planar coordinates in the image
of the HEALPix projection of a sphere of radius 1.

\item {} 
\emph{e} - Eccentricity.

\item {} 
\emph{lon0} - (Optional; default = 0) Central meridian. Any angle is accepted
and gets standardized to lie in the interval -pi \textless{}= \emph{lon0} \textless{} pi.

\item {} 
\emph{degrees} - (Optional; default = False) Boolean. If True, then use 
degrees for input/output instead of radians.

\item {} 
\emph{inverse} - (Optional; default = False) Boolean. If False, then compute
forward function. If True, then compute inverse function.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{u}\PYG{p}{,} \PYG{n}{v} \PYG{o}{=} \PYG{l+m+mi}{82}\PYG{p}{,}\PYG{o}{-}\PYG{l+m+mi}{45}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}E}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,}\PYG{n}{e}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}E}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}
\PYG{g+go}{(81.999999999999986, -44.999999995319058)}
\PYG{g+go}{(82, -45)}
\end{Verbatim}

\end{fulllineitems}

\index{healpix\_sphere() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.healpix_sphere}\pysiglinewithargsret{\code{projections.}\bfcode{healpix\_sphere}}{\emph{u}, \emph{v}, \emph{lon0=0}, \emph{degrees=False}, \emph{inverse=False}}{}
Compute the forward and inverse signature functions of the HEALPix 
projection of the unit sphere with central meridian \emph{lon0}.

INPUT:
\begin{itemize}
\item {} 
\emph{u, v} - If \emph{inverse=False}, then these are geographic coordinates.
Any input angles are accepted and get standardized to lie in the 
intervals -pi \textless{}= \emph{u} \textless{} pi and -pi/2 \textless{}= \emph{v} \textless{}= pi/2 
via wrap\_longitude() and wrap\_latitude().
If \emph{inverse=True}, then these are planar coordinates in the image
of the HEALPix projection of the unit sphere.

\item {} 
\emph{lon0} - (Optional; default = 0) Central meridian. Any angle is accepted
and gets standardized to lie in the interval -pi \textless{}= \emph{lon0} \textless{} pi.

\item {} 
\emph{degrees} - (Optional; default = False) Boolean. If True, then use 
degrees for input/output instead of radians.

\item {} 
\emph{inverse} - (Optional; default = False) Boolean. If False, then compute
forward function. If True, then compute inverse function.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{healpix\PYGZus{}sphere}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{lon0}\PYG{o}{=}\PYG{o}{-}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}
\PYG{g+go}{(0.78539816339744828, 0.0)}
\PYG{g+go}{0.7853981633974483}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{healpix\PYGZus{}sphere}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{lon0}\PYG{o}{=}\PYG{o}{-}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{(0.0, 0.0)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{healpix\PYGZus{}sphere}\PYG{p}{(}\PYG{l+m+mi}{180}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{lon0}\PYG{o}{=}\PYG{o}{-}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{(-2.3561944901923448, 0.0)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{healpix\PYGZus{}sphere}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{180}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{lon0}\PYG{o}{=}\PYG{o}{-}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{(-2.3561944901923448, 0.0)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{u}\PYG{p}{,} \PYG{n}{v} \PYG{o}{=} \PYG{o}{-}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{82}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{healpix\PYGZus{}sphere}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{healpix\PYGZus{}sphere}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}
\PYG{g+go}{(-49.999999999999993, 82.000000000000028)}
\PYG{g+go}{(-50, 82)}
\end{Verbatim}

\end{fulllineitems}

\index{in\_image() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.in_image}\pysiglinewithargsret{\code{projections.}\bfcode{in\_image}}{\emph{x}, \emph{y}, \emph{proj='healpix\_sphere'}, \emph{north=0}, \emph{south=0}}{}
Return True if \emph{(x, y)} lies in the image of the projection \emph{proj}
of the unit sphere, where \emph{proj} is either
`healpix\_sphere' or `rhealpix\_sphere' and \emph{north} and \emph{south} indicate 
the positions of the polar squares in case \emph{proj} = `rhealpix\_sphere'.
Return False otherwise.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{eps} \PYG{o}{=} \PYG{l+m+mi}{0}     \PYG{c}{\PYGZsh{} Test boundary points.}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{hp} \PYG{o}{=} \PYG{p}{[}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{hp}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{in\PYGZus{}image}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }            \PYG{k}{print} \PYG{l+s}{'}\PYG{l+s}{Fail}\PYG{l+s}{'}
\PYG{g+gp}{... }
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{in\PYGZus{}image}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{in\PYGZus{}image}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{eps} \PYG{o}{=} \PYG{l+m+mi}{0}     \PYG{c}{\PYGZsh{} Test boundary points.}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{north}\PYG{p}{,} \PYG{n}{south} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rhp} \PYG{o}{=} \PYG{p}{[}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{north}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{north}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{+} \PYG{p}{(}\PYG{n}{north} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{+} \PYG{p}{(}\PYG{n}{north} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{+} \PYG{p}{(}\PYG{n}{south} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{+} \PYG{p}{(}\PYG{n}{south} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{-}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{south}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{-}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{south}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{-}\PYG{n}{eps}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{,}\PYG{o}{-}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{-} \PYG{n}{eps}\PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{rhp}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{in\PYGZus{}image}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{rhealpix\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }            \PYG{k}{print} \PYG{l+s}{'}\PYG{l+s}{Fail}\PYG{l+s}{'}
\PYG{g+gp}{... }
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{in\PYGZus{}image}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{rhealpix\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{in\PYGZus{}image}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{proj}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{rhealpix\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+go}{False}
\end{Verbatim}

\end{fulllineitems}

\index{para\_lat() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.para_lat}\pysiglinewithargsret{\code{projections.}\bfcode{para\_lat}}{\emph{phi}, \emph{e}, \emph{inverse=False}}{}
Given a point at geographic latitude \emph{phi} on an ellipse of 
eccentricity \emph{e}, return the parametric latitude of the point.
If \emph{inverse=True}, then compute its inverse.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{eta} \PYG{o}{=} \PYG{n}{para\PYGZus{}lat}\PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{WGS84\PYGZus{}E}\PYG{p}{)}\PYG{p}{;} \PYG{n}{eta}
\PYG{g+go}{1.0457420826841251}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{para\PYGZus{}lat}\PYG{p}{(}\PYG{n}{eta}\PYG{p}{,} \PYG{n}{WGS84\PYGZus{}E}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}
\PYG{g+go}{1.0471975511965976}
\PYG{g+go}{1.0471975511965976}
\end{Verbatim}

\end{fulllineitems}

\index{rhealpix\_ellipsoid() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.rhealpix_ellipsoid}\pysiglinewithargsret{\code{projections.}\bfcode{rhealpix\_ellipsoid}}{\emph{u}, \emph{v}, \emph{e}, \emph{lon0=0}, \emph{north=0}, \emph{south=0}, \emph{degrees=False}, \emph{inverse=False}}{}
Compute the forward and inverse signature functions of the rHEALPix 
projection of an oblate ellipsoid with eccentricity \emph{e} whose 
authalic sphere is the unit sphere with central meridian \emph{lon0}. 
The north pole square is put in position \emph{north}, and the south pole
square is put in position \emph{south}.

INPUT:
\begin{itemize}
\item {} 
\emph{u, v} - If \emph{inverse=False}, then these are geographic coordinates.
Any input angles are accepted and get standardized to lie in the 
intervals 
-pi \textless{}= \emph{u} \textless{} pi and -pi/2 \textless{}= \emph{v} \textless{}= pi/2 via wrap\_longitude() and 
wrap\_latitude().
If \emph{inverse= True}, then these are planar coordinates in the
image of the rHEALPix projection of the unit sphere.

\item {} 
\emph{e} - Eccentricity.

\item {} 
\emph{lon0} - (Optional; default = 0) Central meridian. Any angle is accepted
and gets standardized to lie in the interval -pi \textless{}= \emph{lon0} \textless{} pi.

\item {} 
\emph{north, south} - (Optional; defaults = 0, 0) Integers between 0 and 3 
indicating positions of north polar and south polar squares, 
respectively.
See rhealpix\_sphere() docstring for a diagram.

\item {} 
\emph{degrees} - (Optional; default = False) Boolean. If True, then use 
degrees for input/output instead of radians.

\item {} 
\emph{inverse} - (Optional; default = False) Boolean. If False, then compute
forward function. If True, then compute inverse function.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{u}\PYG{p}{,} \PYG{n}{v} \PYG{o}{=} \PYG{l+m+mi}{90}\PYG{p}{,} \PYG{l+m+mi}{72}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{e}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}E}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{healpix\PYGZus{}ellipsoid}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,}\PYG{n}{e}\PYG{o}{=}\PYG{n}{WGS84\PYGZus{}E}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}
\PYG{g+go}{(90.000000000000028, 71.99999999914445)}
\PYG{g+go}{(90, 72)}
\end{Verbatim}

\end{fulllineitems}

\index{rhealpix\_sphere() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.rhealpix_sphere}\pysiglinewithargsret{\code{projections.}\bfcode{rhealpix\_sphere}}{\emph{u}, \emph{v}, \emph{lon0=0}, \emph{north=0}, \emph{south=0}, \emph{degrees=False}, \emph{inverse=False}}{}
Compute the forward and inverse signature functions of the rHEALPix 
projection of the unit sphere with central meridian \emph{lon0}. 
The north pole square is put in position \emph{north}, and the south pole
square is put in position \emph{south}.

INPUT:
\begin{itemize}
\item {} 
\emph{u, v} - If \emph{inverse} = False, then these are geographic coordinates.
Any input angles are accepted and get standardized to lie in the intervals 
-pi \textless{}= \emph{u} \textless{} pi and -pi/2 \textless{}= \emph{v} \textless{}= pi/2 via wrap\_longitude() and 
wrap\_latitude().
If \emph{inverse} = True, then these are planar coordinates in the image
of the rHEALPix projection of the unit sphere.

\item {} 
\emph{lon0} - (Optional; default = 0) Central meridian. Any angle is accepted
and gets standardized to lie in the interval -pi \textless{}= \emph{lon0} \textless{} pi.

\item {} 
\emph{north, south} - (Optional; defaults = 0, 0) Integers between 0 and 3 
indicating positions of north polar and south polar squares, respectively.

\item {} 
\emph{degrees} - (Optional; default = False) Boolean. If True, then use 
degrees for input/output instead of radians.

\item {} 
\emph{inverse} - (Optional; default = False) Boolean. If False, then compute
forward function. If True, then compute inverse function.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{u}\PYG{p}{,} \PYG{n}{v} \PYG{o}{=} \PYG{o}{-}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{82}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{rhealpix\PYGZus{}sphere}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{north}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{south}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{rhealpix\PYGZus{}sphere}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{p}{;} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}
\PYG{g+go}{(-50.000000000000036, 82.000000000000028)}
\PYG{g+go}{(-50, 82)}
\end{Verbatim}

NOTE:

The polar squares are labeled 0, 1, 2, 3 from east to west like this:

\begin{Verbatim}[commandchars=\\\{\}]
east    lon0    west        
*---*---*---*---*
\textbar{} 0 \textbar{} 1 \textbar{} 2 \textbar{} 3 \textbar{}
*---*---*---*---*
\textbar{}   \textbar{}   \textbar{}   \textbar{}   \textbar{}
*---*---*---*---*
\textbar{} 0 \textbar{} 1 \textbar{} 2 \textbar{} 3 \textbar{}
*---*---*---*---*
\end{Verbatim}

\end{fulllineitems}

\index{wrap\_latitude() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.wrap_latitude}\pysiglinewithargsret{\code{projections.}\bfcode{wrap\_latitude}}{\emph{phi}, \emph{degrees=False}}{}
Given a point p on the unit circle at angle \emph{phi} from the positive x-axis,
if p lies in the right half of the circle, then return its angle that lies 
in the interval {[}-pi/2, pi/2{]}.
If p lies in the left half of the circle, then reflect it through the 
origin, and return the angle of the reflected point that lies in the 
interval {[}-pi/2, pi/2{]}.
If \emph{radians} = True, then \emph{phi} and the output are given in radians.
Otherwise, they are given in degrees.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{45.0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{-45.0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{90.0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{90}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{-90.0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{l+m+mi}{135}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{-45.0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}latitude}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{135}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{45.0}
\end{Verbatim}

\end{fulllineitems}

\index{wrap\_longitude() (in module projections)}

\begin{fulllineitems}
\phantomsection\label{projections:projections.wrap_longitude}\pysiglinewithargsret{\code{projections.}\bfcode{wrap\_longitude}}{\emph{lam}, \emph{degrees=False}}{}
Given a point p on the unit circle at angle \emph{lam} from the positive x-axis, 
return its angle theta in the range -pi \textless{}= theta \textless{} pi.
If \emph{radians} = True, then \emph{lam} and the output are given in radians.
Otherwise, they are given in degrees.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}longitude}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{pi} \PYG{o}{+} \PYG{n}{pi}\PYG{p}{)}
\PYG{g+go}{-3.1415926535897931}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}longitude}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{185}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{175.0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}longitude}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{180}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{-180.0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{wrap\PYGZus{}longitude}\PYG{p}{(}\PYG{l+m+mi}{185}\PYG{p}{,} \PYG{n}{degrees}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{-175.0}
\end{Verbatim}

\end{fulllineitems}



\chapter{The grids Module}
\label{grids:module-grids}\label{grids:the-grids-module}\label{grids::doc}\index{grids (module)}
This Python 2.7 module implements the SCENZ-Grid discrete global grid system (DGGS), which is an instance of the rHEALPix DGGS.

CHANGELOG:
\begin{itemize}
\item {} 
Alexander Raichev (AR), 2011-07-11: Initial version

\item {} 
AR, 2011-07-26: Added new functions. 
Improved suids.

\item {} 
AR, 2011-08-05: Extended function capababilities 
to the WGS84 ellipsoid. Improved suids.

\item {} 
AR, 2011-08-31: Added optional central meridian shift in 
HEALPix and rHEALPix projections. 
Added optional polar squares shift in rHEALPix projection.
Added Earth class and restructured and tidied everything.
Fixed rounding bug in HEALPix projection.

\item {} 
AR, 2011-09-01: Added option for entering angles in degrees
in projections and set degrees as default mode in Earth class.
Fixed a rounding bug in auth\_lat().

\item {} 
AR, 2011-09-27: Split projection functions and grid 
functions into separate files.

\item {} 
AR, 2011-10-07: Improved variable and method suids. 
Tested more. Documented more.

\item {} 
AR, 2012-03-06: Refactored to update attribute and method suids and
redo cell ordering.

\item {} 
AR, 2012-03-12: Refactored some more and added CellFamily class.

\item {} 
AR, 2012-03-28: Improved CellFamily methods.

\item {} 
AR, 2012-04-05: Reformatted code to comform to 
\href{http://www.python.org/dev/peps/pep-0008/}{standard Python style}. 
Fixed minimize(), union(), and intersect() to handle empty cell families properly.

\item {} 
AR, 2012-04-11: Improved index() and it's inverse.

\item {} 
AR, 2012-04-13: Rewrote CellFamily to inherit from collections.MutableSequence. Added and optimized CellFamily methods.

\item {} 
AR, 2012-04-16: Removed wildcard imports to avoid suidspace pollution.

\item {} 
AR, 2012-04-23: Added a \emph{filter\_level} option to cell family intersectionand union operations.

\item {} 
AR, 2012-04-25: Changed level 0 cell suids to `N', `O', ..., `S' labeled left to right and top to bottom and changed subcell suids to 0, 1, ..., 8 labeled left to right and top to bottom. Consequently had to change the code that converts between cell suid and cell location.

\item {} 
AR, 2012-05-09: Changed `name' to `suid' and improved intersect\_all() slightly.

\item {} 
AR, 2012-06-08: Changed `suid\_xy' to `suid\_colrow' and cleaned up location(), cell\_from\_point(), and cell\_from\_region().

\item {} 
AR, 2012-07-04: Simplified minimize() and eliminated preprocess().

\item {} 
AR, 2012-07-05: Simplified total ordering definition in Cell class.

\item {} 
AR, 2012-07-06: Added a width() method to Cell class.

\item {} 
AR, 2012-09-17: Fixed rounding errors in nucleus\_and\_vertices() which occurred when interpolation \textgreater{} 0.

\item {} 
AR, 2012-10-15: Changed names. Changed `location' to `ul\_vertex', `center' to `nucleus', `corners' to `vertices'. Introduced the `surface' keyword for cell operations that depend on the distinction between planar and ellipsoidal cells. - AR, 2012-10-24: Added ellipsoidal\_shape() and centroid().

\end{itemize}

EXAMPLES:

Create a WGS84 ellipsoid model of the Earth:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{n}{ellps}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{WGS84}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{south}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{north}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}
\PYG{g+go}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}Earth model\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}}
\PYG{g+go}{lengths measured in meters and angles measured in degrees}
\PYG{g+go}{ellipsoid: WGS84}
\PYG{g+go}{    major radius: 6378137}
\PYG{g+go}{    flattening factor: 0.00335281066475}
\PYG{g+go}{    minor radius: 6356752.31425}
\PYG{g+go}{    eccentricity: 0.0818191908426}
\PYG{g+go}{    authalic sphere radius: 6371007.18092}
\PYG{g+go}{central meridian: 0}
\PYG{g+go}{north pole square position: 2}
\PYG{g+go}{south pole square position: 1}
\PYG{g+go}{max areal resolution: 1.0}
\PYG{g+go}{max cell level: 15}
\end{Verbatim}

Use the HEALPix projection for this Earth to project the
(longitude, latitude) point (45, 60) onto a plane and back again:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{healpix}\PYG{p}{(}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{;} \PYG{n}{p}
\PYG{g+go}{(5003777.338885325, 6823798.3004998406)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{healpix}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{(45.0, 59.999999998490921)}
\end{Verbatim}

Do the same but use the rHEALPix projection:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{rhealpix}\PYG{p}{(}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{;} \PYG{n}{p}
\PYG{g+go}{(5003777.338885325, 6823798.3004998406)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{rhealpix}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{(45.0, 59.999999998490921)}
\end{Verbatim}

Create the `Q3' cell of this Earth and find its four neighbors:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{Q3}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v}
\PYG{g+gp}{... }
\PYG{g+go}{down Q6}
\PYG{g+go}{right Q4}
\PYG{g+go}{up Q0}
\PYG{g+go}{left P5}
\end{Verbatim}

Find the nucleus and vertices of this cell and the level 2 cell 
that contains the nucleus:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{nucleus} \PYG{o}{=} \PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus\PYGZus{}and\PYGZus{}vertices}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{n}{nucleus}
\PYG{g+go}{(1667925.7796284417, 0.0)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{nucleus}\PYG{p}{)}
\PYG{g+go}{Q344}
\end{Verbatim}

NOTES:

All lengths are measured in meters and all angles are measured in radians 
unless indicated otherwise. 
Points lying on the plane are given in rectangular (horizontal, vertical) coordinates, and points lying on the ellipsoid are given in geodetic (longitude, latitude) coordinates unless indicated otherwise.
Below, GGS abbreviates global grid system.

Except when manipulating positive integers, I avoid the modulo function `\%' 
and insted write everything in terms of `floor()'.
This is because Python interprets the sign of `\%' differently than
Java or C, and I don't want to confuse people who are translating this code
to those languages.
\index{Cell (class in grids)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell}\pysiglinewithargsret{\strong{class }\code{grids.}\bfcode{Cell}}{\emph{earth}, \emph{suid=None}, \emph{level\_order\_index=None}, \emph{post\_order\_index=None}}{}
Bases: \code{object}

Represents a cell of the planar or ellipsoidal global grid system (GGS)
relative to a given Earth model.
Cell identifiers are of the form (p\_0, p\_1,...,p\_l), where p\_0 is one of 
the characters `A', `B', `C', `D', `E', `F' and p\_i for i \textgreater{} 0 is one of
the characters `0', `1',..., `8'.
\index{area() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.area}\pysiglinewithargsret{\bfcode{area}}{\emph{surface='plane'}}{}
Return the area of this cell.

\end{fulllineitems}

\index{atomic\_rotate() (grids.Cell static method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.atomic_rotate}\pysiglinewithargsret{\strong{static }\bfcode{atomic\_rotate}}{\emph{quarter\_turns}, \emph{x}}{}
Return the function g that represents the table

\begin{Verbatim}[commandchars=\\\{\}]
0 1 2
3 4 5
6 7 8
\end{Verbatim}

rotated anticlockwise by \emph{quarter\_turns} quarter turns.
The table is then read from left to right and top to bottom
to give the values g(0), g(1), ..., g(8).

INPUT:
\begin{itemize}
\item {} 
\emph{quarter\_turns} - 0, 1, 2, or 3.

\item {} 
\emph{x} - 0, 1, 2, ..., 8, Earth.CELLS0{[}5{]}, Earth.CELLS0{[}1{]}, ..., Earth.CELLS0{[}0{]}.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Cell}\PYG{o}{.}\PYG{n}{atomic\PYGZus{}rotate}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Cell}\PYG{o}{.}\PYG{n}{atomic\PYGZus{}rotate}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Cell}\PYG{o}{.}\PYG{n}{atomic\PYGZus{}rotate}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{8}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Cell}\PYG{o}{.}\PYG{n}{atomic\PYGZus{}rotate}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{6}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Cell}\PYG{o}{.}\PYG{n}{atomic\PYGZus{}rotate}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{0}
\end{Verbatim}

\end{fulllineitems}

\index{centroid() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.centroid}\pysiglinewithargsret{\bfcode{centroid}}{\emph{surface='plane'}}{}
Return the centroid of this planar or ellipsoidal cell.

\end{fulllineitems}

\index{ellipsoidal\_shape() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.ellipsoidal_shape}\pysiglinewithargsret{\bfcode{ellipsoidal\_shape}}{}{}
Return the shape of this cell (`rectangle', `cap', `dart', or 
`trapezoid') when viewed on the ellipsoid.

\end{fulllineitems}

\index{index() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.index}\pysiglinewithargsret{\bfcode{index}}{\emph{order='level'}}{}
Return the index of \emph{self} when it's ordered according to \emph{order}.
Here \emph{order} can be `level' (default) or `post'.        
Indices start at 0.
The empty cell has index None.

The ordering comes from the way of traversing the tree T 
of all cells defined as follows.
The root of T is a non-cell place holder. 
The children of the root are the cells A \textless{} B \textless{} ... \textless{} F.
The children of a cell in T with suid s are s0 \textless{} s1 \textless{} ... \textless{} s8.

The level order index of a nonempty cell is its position 
(starting from 0) in the level order traversal of T starting at cell A.

The post order index of a nonempty cell is its position 
(starting from 0) in the post order traversal of T.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{n}{ellps}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N2}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{level}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+go}{8}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{order}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{post}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+go}{2}
\end{Verbatim}

\end{fulllineitems}

\index{neighbor() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.neighbor}\pysiglinewithargsret{\bfcode{neighbor}}{\emph{direction}}{}
Return the neighboring cell of this cell in the 
direction \emph{direction}.
The direction is relative to this planar neighbor diagram,
where \emph{self} is the middle cell

\begin{Verbatim}[commandchars=\\\{\}]
             up
           *-----*
           \textbar{}     \textbar{}
           \textbar{}     \textbar{}
           \textbar{}     \textbar{}
     *-----*-----*-----*
     \textbar{}     \textbar{} 012 \textbar{}     \textbar{}
left \textbar{}     \textbar{} 345 \textbar{}     \textbar{} right 
     \textbar{}     \textbar{} 678 \textbar{}     \textbar{}
     *-----*-----*-----*
           \textbar{}     \textbar{}
           \textbar{}     \textbar{}
           \textbar{}     \textbar{}
           *-----*
            down
\end{Verbatim}

The tricky part is that the neighbor relationships of the 
six level 0 cells is determined by the positions of those cells
on the surface of a cube, one on each face (and not on a plane).
So sometimes rotating cells in needed to compute neighbors.

INPUT:
\begin{itemize}
\item {} 
\emph{direction} - One of the strings `up', `right', `down', or `left'.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N0}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbor}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{down}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+go}{N3}
\end{Verbatim}

\end{fulllineitems}

\index{neighbors() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.neighbors}\pysiglinewithargsret{\bfcode{neighbors}}{}{}
Return a dictionary of the left, right, down, and up neighbors of this 
cell. 
Direction is relative to this planar neighbor diagram, where \emph{self} is 
the middle cell

\begin{Verbatim}[commandchars=\\\{\}]
                    up
                  *-----*
                  \textbar{}     \textbar{}
                  \textbar{}     \textbar{}
                  \textbar{}     \textbar{}
            *-----*-----*-----*
            \textbar{}     \textbar{} 012 \textbar{}     \textbar{}
       left \textbar{}     \textbar{} 345 \textbar{}     \textbar{} right 
            \textbar{}     \textbar{} 678 \textbar{}     \textbar{}
            *-----*-----*-----*
                  \textbar{}     \textbar{}
                  \textbar{}     \textbar{}
                  \textbar{}     \textbar{}
                  *-----*
                   down

The tricky part is that the neighbor relationships of the 
six level 0 cells is determined by the positions of those cells
on the surface of a cube, one on each face (and not a plane).
So sometimes rotating cells in needed to compute neighbors.
\end{Verbatim}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N0}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{neighbors}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v}
\PYG{g+gp}{... }
\PYG{g+go}{down N3}
\PYG{g+go}{right N1}
\PYG{g+go}{up Q2}
\PYG{g+go}{left R0}
\end{Verbatim}

\end{fulllineitems}

\index{nucleus\_and\_vertices() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.nucleus_and_vertices}\pysiglinewithargsret{\bfcode{nucleus\_and\_vertices}}{\emph{surface='plane'}, \emph{interpolation=0}}{}
Return the nucleus of this planar or ellipsoidal cell along 
with its corner points interpolated by \emph{3**(interpolation)} points 
along each edge.
The nucleus is the first point in the output list and the remaining 
points are the boundary points enumerated from the upleft corner
to the downleft corner to the downright corner to the upright corner
to the upleft corner (but not including the downright corner in
the list again).
The output for ellipsoidal cells is the projection onto the ellipsoid
of the output for planar cells.  In particular, while the 
nucleus of a planar cell is its centroid, the nucleus 
of an ellipsoidal cell is not its centroid.
To compute the centroid of a cell, use centroid() below.

NOTE:

The interpolation option is intended mostly for drawing the
boundary of \emph{self} with varying degrees of smoothness.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{nucleus\PYGZus{}and\PYGZus{}vertices}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[(-2.3561944901923448, 1.5707963267948966), (-3.141592653589793, 2.356194490192345), (-3.1415926535897931, 0.78539816339744828), (-1.5707963267948966, 0.78539816339744828), (-1.5707963267948966, 2.3561944901923448)]}
\end{Verbatim}

\end{fulllineitems}

\index{predecessor() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.predecessor}\pysiglinewithargsret{\bfcode{predecessor}}{\emph{level=None}}{}
Return the greatest level \emph{level} cell less than \emph{self}.
Note: \emph{self} need not be a level \emph{level} cell.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N08}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{predecessor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N07}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{predecessor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{None}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{predecessor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{None}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{predecessor}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N088}
\end{Verbatim}

\end{fulllineitems}

\index{region() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.region}\pysiglinewithargsret{\bfcode{region}}{}{}
Return the region, `equatorial' or `polar', of this cell.

\end{fulllineitems}

\index{rotate() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.rotate}\pysiglinewithargsret{\bfcode{rotate}}{\emph{quarter\_turns}}{}
Return the cell that is the result of rotating this cell 
\emph{quarter\_turns} quarter\_turns.
Used in neighbor().

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N0}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{N0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{N2}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{N8}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+go}{N6}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{rotate}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{N0}
\end{Verbatim}

\end{fulllineitems}

\index{str9() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.str9}\pysiglinewithargsret{\bfcode{str9}}{}{}
Return the suid of \emph{self} as a base 9 numeral.
Just need to convert the leading character to a digit between 0 and 8.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N130534}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{str9}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{0130534}
\end{Verbatim}

\end{fulllineitems}

\index{subcell() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.subcell}\pysiglinewithargsret{\bfcode{subcell}}{\emph{other}}{}
Subcell (subset) relation on cells.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N1}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{a}\PYG{o}{.}\PYG{n}{subcell}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{b}\PYG{o}{.}\PYG{n}{subcell}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{False}
\end{Verbatim}

\end{fulllineitems}

\index{subcells() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.subcells}\pysiglinewithargsret{\bfcode{subcells}}{\emph{level=None}}{}
Generator function for the set of level \emph{level} subcells of \emph{self}.  
If \emph{level=None}, then return a generator function for the children
of \emph{self}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{k}{for} \PYG{n}{z} \PYG{o+ow}{in} \PYG{n}{c}\PYG{o}{.}\PYG{n}{subcells}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{['N00', 'N01', 'N02', 'N03', 'N04', 'N05', 'N06', 'N07', 'N08', 'N10', 'N11', 'N12', 'N13', 'N14', 'N15', 'N16', 'N17', 'N18', 'N20', 'N21', 'N22', 'N23', 'N24', 'N25', 'N26', 'N27', 'N28', 'N30', 'N31', 'N32', 'N33', 'N34', 'N35', 'N36', 'N37', 'N38', 'N40', 'N41', 'N42', 'N43', 'N44', 'N45', 'N46', 'N47', 'N48', 'N50', 'N51', 'N52', 'N53', 'N54', 'N55', 'N56', 'N57', 'N58', 'N60', 'N61', 'N62', 'N63', 'N64', 'N65', 'N66', 'N67', 'N68', 'N70', 'N71', 'N72', 'N73', 'N74', 'N75', 'N76', 'N77', 'N78', 'N80', 'N81', 'N82', 'N83', 'N84', 'N85', 'N86', 'N87', 'N88']}
\end{Verbatim}

\end{fulllineitems}

\index{successor() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.successor}\pysiglinewithargsret{\bfcode{successor}}{\emph{level=None}}{}
Return the least level \emph{level} cell greater than \emph{self}.
Note: \emph{self} need not be a level \emph{level} cell.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N82}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{successor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N83}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{successor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{O}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{successor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{O0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{successor}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{N830}
\end{Verbatim}

\end{fulllineitems}

\index{suid\_colrow() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.suid_colrow}\pysiglinewithargsret{\bfcode{suid\_colrow}}{}{}
Return the pair of row- and column-suids of \emph{self}, each as tuples.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N73}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{xn}\PYG{p}{,} \PYG{n}{yn} \PYG{o}{=} \PYG{n}{c}\PYG{o}{.}\PYG{n}{suid\PYGZus{}colrow}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{xn} \PYG{o}{==} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{yn} \PYG{o}{==} \PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{suid\_from\_index() (grids.Cell static method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.suid_from_index}\pysiglinewithargsret{\strong{static }\bfcode{suid\_from\_index}}{\emph{earth}, \emph{index}, \emph{order='level'}}{}
Return the suid of a cell from its index.
The index is according to the cell ordering \emph{order},
which can be `level' (default) or `post'.
See the \emph{index()} docstring for more details on orderings.
For internal use.

\end{fulllineitems}

\index{ul\_vertex() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.ul_vertex}\pysiglinewithargsret{\bfcode{ul\_vertex}}{\emph{surface='plane'}}{}
Return the upper left (northwest) vertex of this planar or 
ellipsoidal cell.

WARNING: The upper left vertex of a cell might not lie in the cell, 
because not all cells contain their boundary.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N0}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}\PYG{o}{.}\PYG{n}{ul\PYGZus{}vertex}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{o}{-}\PYG{n}{pi}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{width() (grids.Cell method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Cell.width}\pysiglinewithargsret{\bfcode{width}}{\emph{surface='plane'}}{}
Return the width of this cell. If \emph{surface='ellipsoid'}, then
return None, because ellipsoidal cells don't have a fixed
width.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N8}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}
\PYG{g+go}{N8}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{width}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{CellFamily (class in grids)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.CellFamily}\pysiglinewithargsret{\strong{class }\code{grids.}\bfcode{CellFamily}}{\emph{cells=None}, \emph{min\_level=None}, \emph{max\_level=None}, \emph{sort=True}, \emph{eliminate\_subcells=True}}{}
Bases: \code{\_abcoll.MutableSequence}

A subcell-free ordered list of cells along with the minimum level of 
the cells in family the maximum level of the cells in family.
\index{add() (grids.CellFamily method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.CellFamily.add}\pysiglinewithargsret{\bfcode{add}}{\emph{key}}{}
Add \emph{key} to \emph{self} if \emph{key} is not a subcell of any cell of \emph{self}.
Uses bisection to find the insertion point in O(log(len(self)))
comparisons.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{CellFamily}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{E}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{del} \PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;} \PYG{k}{print} \PYG{n}{f}
\PYG{g+go}{['N', 'O', 'Q', 'R', 'S']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{P3}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}
\PYG{g+go}{['N', 'O', 'P3', 'Q', 'R', 'S']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{O3}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}    \PYG{c}{\PYGZsh{} Should do nothing.}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}
\PYG{g+go}{['N', 'O', 'P3', 'Q', 'R', 'S']}
\end{Verbatim}

\end{fulllineitems}

\index{insert() (grids.CellFamily method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.CellFamily.insert}\pysiglinewithargsret{\bfcode{insert}}{\emph{index}, \emph{value}}{}
Insert the \emph{value} into \emph{self} at index \emph{index}.
Warning: for internal use only; does not maintain sorted order.
Use \emph{add()} to add cells to \emph{self}.

\end{fulllineitems}

\index{intersect() (grids.CellFamily method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.CellFamily.intersect}\pysiglinewithargsret{\bfcode{intersect}}{\emph{other}, \emph{filter\_level=None}}{}
Return the minimal cell family v for the intersection of the regions 
of \emph{self} and \emph{other}. 
If a nonnegative integer \emph{filter\_level} is given, then return the cell
family comprised of the cell's of v at levels \textless{}= \emph{filter\_level}.

Uses O(max(m, n)) cell operations, where m = \emph{len(self)} and
n = \emph{len(other)}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{P}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{CellFamily}\PYG{p}{(}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{+} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{subcells}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}
\PYG{g+go}{['N0', 'N1', 'N2', 'N3', 'P']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{g} \PYG{o}{=} \PYG{n}{CellFamily}\PYG{p}{(}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]} \PYG{o}{+} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{subcells}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{g}
\PYG{g+go}{['N3', 'N4', 'N5', 'N6', 'N7', 'N8', 'P']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}\PYG{o}{.}\PYG{n}{intersect}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\PYG{g+go}{['N3', 'P']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}\PYG{o}{.}\PYG{n}{intersect}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{filter\PYGZus{}level}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{['P']}
\end{Verbatim}

\end{fulllineitems}

\index{intersect\_all() (grids.CellFamily method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.CellFamily.intersect_all}\pysiglinewithargsret{\bfcode{intersect\_all}}{\emph{others}, \emph{filter\_level=None}}{}
Return the minimal cell family v for the intersection of the regions
of \emph{self} and the cell families in the list \emph{others}.
If a nonnegative integer \emph{filter\_level} is given, then return the cell
family comprised of the cell's of v at levels \textless{}= \emph{filter\_level}.

Uses O(n) cell operations, where n is the maximum of \emph{len(self)} and
the lengths of the cell families in \emph{others}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cell\PYGZus{}families} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{E}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{cell\PYGZus{}families}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{CellFamily}\PYG{p}{(}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{cell\PYGZus{}families}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}\PYG{o}{.}\PYG{n}{intersect\PYGZus{}all}\PYG{p}{(}\PYG{n}{cell\PYGZus{}families}\PYG{p}{)}
\PYG{g+go}{[]}
\end{Verbatim}

\end{fulllineitems}

\index{minimize() (grids.CellFamily method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.CellFamily.minimize}\pysiglinewithargsret{\bfcode{minimize}}{}{}
Return the minimal cell family that has the same region 
as \emph{self}.

Uses O(len(self)) cell operations.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{CellFamily}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{c}\PYG{o}{.}\PYG{n}{subcells}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}
\PYG{g+go}{['N0', 'N1', 'N2', 'N3', 'N4', 'N5', 'N6', 'N7', 'N8']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}\PYG{o}{.}\PYG{n}{minimize}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{['N']}
\end{Verbatim}

\end{fulllineitems}

\index{union() (grids.CellFamily method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.CellFamily.union}\pysiglinewithargsret{\bfcode{union}}{\emph{other}, \emph{filter\_level=None}}{}
Return the cell family u that is the  minimizeed union of \emph{self} 
and \emph{other}, that is, the smallest cell family whose region is the 
union of the regions of \emph{self} and \emph{other}.
If a nonnegative integer \emph{filter\_level} is given, then return the cell
family comprised of the cell's of u at levels \textless{}= \emph{filter\_level}.
Do not set \emph{minimize\_first=False} unless you know that the input
cell families are already minimizeed.

Uses O(max(m, n)) cell operations, where m = \emph{len(self)} and
n = \emph{len(other)}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{N}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b1} \PYG{o}{=} \PYG{n}{Cell}\PYG{p}{(}\PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{P1}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{CellFamily}\PYG{p}{(}\PYG{p}{[}\PYG{n}{b1}\PYG{p}{]} \PYG{o}{+} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{subcells}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}
\PYG{g+go}{['N0', 'N1', 'N2', 'N3', 'P1']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{g} \PYG{o}{=} \PYG{n}{CellFamily}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{subcells}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{g}
\PYG{g+go}{['N3', 'N4', 'N5', 'N6', 'N7', 'N8']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}\PYG{o}{.}\PYG{n}{union}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\PYG{g+go}{['N', 'P1']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}\PYG{o}{.}\PYG{n}{union}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{filter\PYGZus{}level}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{['N']}
\end{Verbatim}

\end{fulllineitems}

\index{union\_all() (grids.CellFamily method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.CellFamily.union_all}\pysiglinewithargsret{\bfcode{union\_all}}{\emph{others}, \emph{filter\_level=None}, \emph{minimize\_first=True}}{}
Return the cell family u that is the union of the regions of this cell 
family and cell families in the list \emph{others}. 
If a nonnegative integer \emph{filter\_level} is given, then return the cell
family comprised of the cell's of u at levels \textless{}= \emph{filter\_level}.

Uses O(n) cell operations, where n is the maximum of \emph{len(self)} and
the lengths of the cell families in \emph{others}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{cell\PYGZus{}families} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n}{E}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{cell\PYGZus{}families}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{CellFamily}\PYG{p}{(}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{cell\PYGZus{}families}\PYG{p}{)}
\PYG{g+go}{54}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{f} \PYG{o}{=} \PYG{n}{cell\PYGZus{}families}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}
\PYG{g+go}{['N0']}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{f}\PYG{o}{.}\PYG{n}{union\PYGZus{}all}\PYG{p}{(}\PYG{n}{cell\PYGZus{}families}\PYG{p}{)}
\PYG{g+go}{['N', 'O', 'P', 'Q', 'R', 'S']}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{Earth (class in grids)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth}\pysiglinewithargsret{\strong{class }\code{grids.}\bfcode{Earth}}{\emph{ellps='WGS84'}, \emph{degrees=True}, \emph{lon0=0}, \emph{north=0}, \emph{south=0}, \emph{max\_areal\_resolution=1.0}}{}
Bases: \code{object}

Represents a model of the Earth its planar and ellipsoidal GGSs.
\index{CELLS0 (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.CELLS0}\pysigline{\bfcode{CELLS0}\strong{ = {[}'N', `O', `P', `Q', `R', `S'{]}}}
\end{fulllineitems}

\index{WGS84 (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.WGS84}\pysigline{\bfcode{WGS84}\strong{ = \{`a': 6378137, `b': 6356752.314245179, `e': 0.081819190842621486, `figure': `ellipsoid', `f': 0.0033528106647474805, `R': 6371007.1809184756\}}}
\end{fulllineitems}

\index{WGS84\_asphere (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.WGS84_asphere}\pysigline{\bfcode{WGS84\_asphere}\strong{ = \{`R': 6371007.1809184756, `figure': `sphere'\}}}
\end{fulllineitems}

\index{cell() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.cell}\pysiglinewithargsret{\bfcode{cell}}{\emph{suid=None}, \emph{level\_order\_index=None}, \emph{post\_order\_index=None}}{}
Return a cell of this Earth model either from its SUID or 
from its level and index. The cell can be interpreted as lying on the 
plane or on the ellipsoid, depending on the \emph{surface} option given 
in the instance methods below.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N45}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{Cell}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}
\PYG{g+go}{N45}
\end{Verbatim}

\end{fulllineitems}

\index{cell\_area() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.cell_area}\pysiglinewithargsret{\bfcode{cell\_area}}{\emph{level}, \emph{surface='plane'}}{}
For this Earth model, return the area of a planar or ellipsoiadl cell
at level \emph{level}.

\end{fulllineitems}

\index{cell\_from\_point() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.cell_from_point}\pysiglinewithargsret{\bfcode{cell\_from\_point}}{\emph{level}, \emph{p}, \emph{surface='plane'}}{}
For this Earth model, return the planar or ellipsoidal cell at level 
\emph{level} that contains the point \emph{p}.

INPUT:
\begin{itemize}
\item {} 
\emph{level} - Cell level.

\item {} 
\emph{p} - A point on the plane or ellipsoid given in rectangular or 
geodetic coordinates, respectively.

\item {} 
\emph{surface} - (Optional; default='plane') One of `plane' or 
`ellipsoid', indicating whether the given point and returned cell 
both lie on the plane or on the ellipsoid.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{WGS84}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}point}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}
\PYG{g+go}{Q33}
\end{Verbatim}

\end{fulllineitems}

\index{cell\_from\_region() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.cell_from_region}\pysiglinewithargsret{\bfcode{cell\_from\_region}}{\emph{ul}, \emph{dr}, \emph{surface='plane'}}{}
Return the smallest planar or ellipsoidal cell wholly containing 
the region bounded by the axis-aligned rectangle with upper left 
and lower right vertices given by the the points \emph{ul} and \emph{dr}, 
respectively.  
If such as cell does not exist, then return None.
If \emph{surface='plane'}, then \emph{ul} and \emph{dr} and the returned cell
are interpreted as lying on the plane.
If \emph{surface='ellipsoid'}, then they are interpreted as lying on
the ellipsoid and the bounding rectangle is interpreted as being
longitude-latitude aligned.    
To specify an ellipsoidal cap region (whose centroid is the north
or south pole and whose boundary is a parallel of latitude),
set ul = (-pi, pi/2) or (-pi, -pi/2), indicating a north or south pole,
respectively, and set dr = (-pi, phi), where phi is the latitude of
the boundary.
Works on defunct (point and line) planar rectangles too.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{p}{(}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell\PYGZus{}from\PYGZus{}region}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{c}
\PYG{g+go}{Q}
\end{Verbatim}

\end{fulllineitems}

\index{cell\_width() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.cell_width}\pysiglinewithargsret{\bfcode{cell\_width}}{\emph{level}, \emph{surface='plane'}}{}
For this Earth model, return the width of a planar cell at level 
\emph{level}.
If \emph{surface != `plane'}, then return None, because ellipsoidal cells
don't have constant width.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{cell\PYGZus{}width}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{1.5707963267948966}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{cell\PYGZus{}width}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{0.5235987755982988}
\end{Verbatim}

\end{fulllineitems}

\index{child\_order (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.child_order}\pysigline{\bfcode{child\_order}\strong{ = \{0: (0, 0), (0, 1): 3, 2: (2, 0), (0, 0): 0, 4: (1, 1), 5: (2, 1), 6: (0, 2), 1: (1, 0), 8: (2, 2), (1, 2): 7, (2, 1): 5, (1, 1): 4, (2, 0): 2, 3: (0, 1), (2, 2): 8, 7: (1, 2), (1, 0): 1, (0, 2): 6\}}}
\end{fulllineitems}

\index{col (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.col}\pysigline{\bfcode{col}\strong{ = 2}}
\end{fulllineitems}

\index{combine\_caps() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.combine_caps}\pysiglinewithargsret{\bfcode{combine\_caps}}{\emph{u}, \emph{v}, \emph{inverse=False}}{}
Return the combine\_caps() transformation of the point \emph{(u, v)} 
(or its inverse if \emph{inverse=True}) appropriate to this Earth.
It maps the HEALPix projection to the rHEALPix projection.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}\PYG{o}{.}\PYG{n}{combine\PYGZus{}caps}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}\PYG{o}{.}\PYG{n}{combine\PYGZus{}caps}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{ellipsoids (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.ellipsoids}\pysigline{\bfcode{ellipsoids}\strong{ = \{`unit\_sphere': \{`R': 1, `figure': `sphere'\}, `WGS84\_asphere': \{`R': 6371007.1809184756, `figure': `sphere'\}, `WGS84': \{`a': 6378137, `b': 6356752.314245179, `e': 0.081819190842621486, `figure': `ellipsoid', `f': 0.0033528106647474805, `R': 6371007.1809184756\}\}}}
\end{fulllineitems}

\index{grid() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.grid}\pysiglinewithargsret{\bfcode{grid}}{\emph{level}}{}
Generator function for all the cells at level \emph{level}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{g} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{g}\PYG{p}{]}
\PYG{g+go}{['N', 'O', 'P', 'Q', 'R', 'S']}
\end{Verbatim}

\end{fulllineitems}

\index{healpix() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.healpix}\pysiglinewithargsret{\bfcode{healpix}}{\emph{u}, \emph{v}, \emph{inverse=False}}{}
Return the HEALPix projection of point \emph{(u, v)} (or its inverse if 
\emph{inverse=True}) for this Earth model.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{180}\PYG{p}{,} \PYG{l+m+mi}{90}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}\PYG{o}{.}\PYG{n}{healpix}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}\PYG{o}{.}\PYG{n}{healpix}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{interval() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.interval}\pysiglinewithargsret{\bfcode{interval}}{\emph{a}, \emph{b}}{}
Generator function for all the level \emph{max(a.level, a.level)} 
cells between cell \emph{a} and cell \emph{b} (inclusive and with respect to the     
postorder ordering on cells).
Note that \emph{a} and \emph{b} don't have to lie at the same level.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N10}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{E}\PYG{o}{.}\PYG{n}{cell}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{N3}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{k}{for} \PYG{n}{z} \PYG{o+ow}{in} \PYG{n}{E}\PYG{o}{.}\PYG{n}{interval}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{]}
\PYG{g+go}{['N10', 'N11', 'N12', 'N13', 'N14', 'N15', 'N16', 'N17', 'N18', 'N20', 'N21', 'N22', 'N23', 'N24', 'N25', 'N26', 'N27', 'N28', 'N30', 'N31', 'N32', 'N33', 'N34', 'N35', 'N36', 'N37', 'N38']}
\end{Verbatim}

\end{fulllineitems}

\index{num\_cells() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.num_cells}\pysiglinewithargsret{\bfcode{num\_cells}}{\emph{level\_a}, \emph{level\_b=None}, \emph{subcells=False}}{}
Return the number of cells at levels \emph{level\_a}
to \emph{level\_b} (inclusive).
Assume \emph{level\_a \textless{}= level\_b}.
If \emph{subcells=True}, then return the number of subcells at levels
\emph{level\_a} to \emph{level\_b} (inclusive) of a cell at level \emph{level\_a}.
If \emph{level\_b=None} and \emph{subcells=False, then return the number of
cells at level {}`level\_a}.
If \emph{level\_b=None} and \emph{subcells=True}, then return the number of
subcells from level \emph{level\_a} to level \emph{self.max\_level}.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{6}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{60}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{subcells}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{231627523606480}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{subcells}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{10}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E}\PYG{o}{.}\PYG{n}{num\PYGZus{}cells}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{subcells}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{10}
\end{Verbatim}

\end{fulllineitems}

\index{order (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.order}\pysigline{\bfcode{order}\strong{ = 8}}
\end{fulllineitems}

\index{project() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.project}\pysiglinewithargsret{\bfcode{project}}{\emph{p}, \emph{source='lonlat'}, \emph{target='rhealpix'}}{}
Transform a point \emph{p} from the image of the \emph{source} 
projection to the image of the \emph{target} projection.

INPUT:
\begin{itemize}
\item {} 
\emph{p} - A point in geographic space, in the HEALPix projection,
or in the rHEALPix projection.

\item {} 
\emph{source, target} - One of `lonlat', `healpix', or `rhealpix'.

\end{itemize}

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{rad2deg}\PYG{p}{,} \PYG{n}{arcsin}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{o}{-}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{phi0} \PYG{o}{=} \PYG{n}{rad2deg}\PYG{p}{(}\PYG{n}{arcsin}\PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{/} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{phi0}
\PYG{g+go}{41.8103148958}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}\PYG{o}{.}\PYG{n}{project}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{source}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{rhealpix}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{target}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{lonlat}\PYG{l+s}{'}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{phi0}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{random\_cell() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.random_cell}\pysiglinewithargsret{\bfcode{random\_cell}}{\emph{level=None}}{}
Return a cell chosen of level \emph{level} chosen uniformly at random among
all level \emph{level} cells.
If \emph{level=None}, then \emph{level} is first chosen uniformly randomly in
{[}0,..,self.max\_level{]}

\end{fulllineitems}

\index{rhealpix() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.rhealpix}\pysiglinewithargsret{\bfcode{rhealpix}}{\emph{u}, \emph{v}, \emph{inverse=False}}{}
Return the rHEALPix projection of the point \emph{(u, v)} (or its inverse if 
\emph{inverse=True}) appropriate to this Earth.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{E} \PYG{o}{=} \PYG{n}{Earth}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{unit\PYGZus{}sphere}\PYG{l+s}{'}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{q} \PYG{o}{=} \PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{180}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mi}{90}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}\PYG{o}{.}\PYG{n}{rhealpix}\PYG{p}{(}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{print} \PYG{n}{E}\PYG{o}{.}\PYG{n}{rhealpix}\PYG{p}{(}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)} \PYG{o}{==} \PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{-}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{row (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.row}\pysigline{\bfcode{row}\strong{ = 2}}
\end{fulllineitems}

\index{sample() (grids.Earth method)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.sample}\pysiglinewithargsret{\bfcode{sample}}{\emph{cells}, \emph{k}}{}
Return a \emph{k} length list of unique elements chosen at random without
replacement from the cell population sequence \emph{cells}.

\end{fulllineitems}

\index{unit\_sphere (grids.Earth attribute)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.Earth.unit_sphere}\pysigline{\bfcode{unit\_sphere}\strong{ = \{`R': 1, `figure': `sphere'\}}}
\end{fulllineitems}


\end{fulllineitems}

\index{scale() (in module grids)}

\begin{fulllineitems}
\phantomsection\label{grids:grids.scale}\pysiglinewithargsret{\code{grids.}\bfcode{scale}}{\emph{x}, \emph{factor}, \emph{inverse=False}}{}
Multiply (all the elements of) \emph{x} by the number \emph{factor} or by 1/\emph{factor} 
if \emph{inverse=True}.
Here \emph{x} can be a number or a tuple of numbers.

EXAMPLES:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{scale}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{10}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{scale}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{2.5}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{scale}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mf}{3.1}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{(10, 6.2)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{scale}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mf}{3.1}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{inverse}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{(2.5, 1.55)}
\end{Verbatim}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}

\begin{thebibliography}{GRS2013}
\bibitem[GRS2013]{GRS2013}{\phantomsection\label{introduction:grs2013} 
Robert Gibb, Alexander Raichev, Michael Speth, \href{http://code.scenzgrid.org/index.php/p/scenzgrid-py/source/tree/master/rhealpix\_dggs\_paper/rhealpix\_dggs.pdf}{The rHEALPix discrete global grid system}, in preparation, 2013.
}
\end{thebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{g}
\item {\texttt{grids}}, \pageref{grids:module-grids}
\indexspace
\bigletter{p}
\item {\texttt{projections}}, \pageref{projections:module-projections}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
